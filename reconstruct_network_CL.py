import os.path
import os
from rank_pathways import *
import nearshortest
import near_shortest_undirected
import parsego
import extract_data

''' This code extract the list of mutated genes for each cell line, convert genes into unipro unique identifiers
then for each cell line reconstruct the prior knowledge network. 
This prior knowledge network composed by the assembly of all pathway from kegg reactom and panther is then pruned in function of transcriptomic data for each cell line
Then for each protein (mutated gene) as source  a reachable list of nodes is calculated with single_source_dijkstra, 
 a random walk is performed, again a single_source_dijkstra in order to have the refined weight. The network is converted into a undirected one.
 Then a search for shortest path extract a subnetwork. The subnetwork is again converted into directed one. The procedure is repeated for each target.
 The reusult network for a cell line is the union of the differents subnetwork extracted'''



'''This part extract list of uniprot corresponding to gene mutated for each cell line, gene_to_uniprot file has been generated by data_to_uniprot.py 
and completed by mannually searching in gene_to_uniprot_completed'''
gene_to_uniprot=extract_data.gene_to_uniprot()


'''extract the list of uniprot  for each cell line'''
prot_changed_CL=extract_data.extract_mutation()
  

'''extract the list of cell line with RNAseq data available '''
f=open('/home/buffard/code/données_transcriptome/cell_line_with_RNA.csv','r')
cell_line_RNA=f.readline().strip().split('\t')

'''add genes from cytogenetic abnormallity'''
extra_protadd=extract_data.extra_prot()
for cell_line in prot_changed_CL.keys():
    if cell_line in extra_protadd.keys():
        if len(extra_protadd[cell_line])!=0:
            for prot in extra_protadd[cell_line]:
                print(extra_protadd[cell_line])
                prot_changed_CL[cell_line].append(prot)

#################################################################################################



rpath = os.path.join('random_walk')
cachedir=os.path.join("pathwaycache", "all_pathways_KEGG&PC2", "pathways")

outfolder =  "output/"
if not os.path.isdir(outfolder):
	os.makedirs(outfolder)
     
     
rank_file = os.path.join(outfolder, "all__pathways.tsv" )
network_file_name = os.path.join(outfolder, "all__network" )
members = os.path.join(cachedir, "members.txt")
pathways, allmembers = load_pathways(members)


def globalProt_score(source_node,target_node):
	return 1
def get_rate(weight):
	return 5

#### reconstruct network for each cell_line ################

for cell_line in prot_changed_CL.keys():
    if cell_line not in cell_line_RNA or cell_line!="XG25": continue
    print("cell line : "+ cell_line)
    cell_line_nodes_absent=extract_data.extract_absent_nodes(cell_line)

    outfolder =  "output/"
    folder=cell_line
    outfolder=outfolder+folder
    cat_folder=outfolder+"/all_targets"
    if not os.path.exists(outfolder): 
        os.mkdir(outfolder)
    if not os.path.exists(cat_folder):
        os.mkdir(cat_folder)

    targets=set(prot_changed_CL[cell_line])
    rank(targets, pathways, allmembers, rank_file) #analyse the enrichment for each pathway
    build_network(rank_file, network_file_name, targets,cachedir,2)
    interactions=add_weights('%s.tsv' % network_file_name,globalProt_score)
    G = nx.DiGraph()
    G = nearshortest.load_interactions(interactions)
    # Surpess all nodes not express in transcriptomic data depending on cell line
    G.remove_nodes_from(cell_line_nodes_absent)
    clean_targets=set()
    for target in targets:
        if target in G.nodes:
            clean_targets.add(target)
    all_targets=[uid for uid in clean_targets]
    ptyr_file=open ("./targets/all_targets.txt","w")

    for t in all_targets:
        ptyr_file.write(t+"\n")
    ptyr_file.close()
    folder=cell_line+"/all_targets"

    selected_nodes = {}
    selected_edges = {}
    for source in clean_targets:
        if source not in G.nodes or G.out_degree(source)==0 :continue
        ranks=nx.single_source_dijkstra_path_length(G, source) #definit les noeuds accessibles dn obligés de faire sur du dirigé
        reachable = G.subgraph(ranks)
        Gs = nearshortest.random_walk(reachable, get_rate,source , rpath)
        ranks=nx.single_source_dijkstra_path_length(Gs, source)
        nearshortest.save_graph(reachable, os.path.join(outfolder, "reachable.tsv"))

        G_undirected=Gs.to_undirected()
        #solve the problem of the function to_undirected which take the last weight when arc in both direction 
        for node in Gs:
            for ngbr in nx.neighbors(Gs, node):
                if node in nx.neighbors(Gs, ngbr):
                    G_undirected.edges[node, ngbr]['weight'] = (
                        Gs.edges[node, ngbr]['weight'] + Gs.edges[ngbr, node]['weight']/2
                    )
            
        tfile="all_targets.txt"
        title="%s_shortest"%cell_line
        
        selected_edges_new,selected_nodes_new = near_shortest_undirected.find_paths(G_undirected,Gs, ranks, clean_targets, "all_targets.txt", overflow=0, title="%s_shortest"%cell_line, outfolder=outfolder+"all_targets")
        if len(selected_edges_new)!=0:
            selected_nodes.update(selected_nodes_new)
            for edge in selected_edges_new.keys():
                if (edge[0],edge[1]) not in selected_edges.keys() and (edge[1],edge[0]) not in selected_edges.keys() :

                    selected_edges[edge]=selected_edges_new[edge]
    
    #print(selected_edges_new)
    with open( os.path.join(cat_folder, "%s_%s_edges.tsv" % (title,tfile)), 'w' ) as out:
        out.write("Source\tTarget\tType\tSign\tOverflow\tWeight\n")
        for e in selected_edges:
            if G.get_edge_data(e[0],e[1]) is None: #check le sens originel du lien
                w = G.get_edge_data(e[1],e[0])['weight']
                out.write("%s\t%s\t%s\t%s\n" % (e[1],e[0],selected_edges[e],w))
            else:
                if G.get_edge_data(e[1],e[0]) is None:
                    w=G.get_edge_data(e[0],e[1])['weight']
                    out.write("%s\t%s\t%s\t%s\n" % (e[0],e[1],selected_edges[e],w))
                else:
                    w=G.get_edge_data(e[0],e[1])['weight']
                    out.write("%s\t%s\t%s\t%s\n" % (e[0],e[1],selected_edges[e],w))
                    w=G.get_edge_data(e[1],e[0])['weight']
                    out.write("%s\t%s\t%s\t%s\n" % (e[1],e[0],selected_edges[e],w))                                        
    out.close()
    with open( os.path.join(cat_folder, "%s_%s_nodes.tsv" % (title,tfile)), 'w' ) as out:

        out.write("UID\tLabel\tBest\tOverflow\tTarget\n")
        for n in selected_nodes:
            if n in targets:
                target_value="X"
            else:
                target_value="db_prot"
            #b = ranks[n]

            if converter.handler.to_symbol(n):
                out.write("%s\t%s\t%s\t%s\n" % (n,converter.handler.to_symbol(n),  -selected_nodes[n],target_value, ))
            else:
                out.write("%s\t%s\t%s\t%s\n" % (n,n, -selected_nodes[n],target_value,))
    out.close()



